Traveling Salesman Problem

For this project we were given a set of input files representing complete graphs of cities to solve as TSP problems. Our goal was to come up with an algorithm that could solve the tsp_example_#.txt problems within 25% of the optimal solution (our_sol/opt_sol <= 1.25). There was also a competition held to see which algorithm created could solve the test-input-#.txt input files as close to optimal as possible within a 3 minute time window. These, for grading purposes, were also intended to be within 25% of optimal but we were not provided an optimal path to check our work.

The approaches in the TSP#.cpp files were all conceived of and created by me. Please note that I am not claiming novelty of the idea, but the data structures and specific implementation of the ideas were my own. I focused mostly on greedy approaches because implementation was straightforward and early results showed ~25% accuracy for the 3 tsp_example_#.txt files that I knew the optimal path lengths for. There were a couple of other ideas I tried as well though.

The approaches I took were as follows:

TSP1.cpp: A basic greedy algorithm that always starts at the first city read in
TSP2.cpp: A greedy algorithm that tries ALL cities as starting points and remembers the best route calculated
TSP3.cpp: A city was selected at random, then another city was selected. If the distance to the second city was closer than the current city adjacent in the list, these cities were swapped. A timer was set to run the algorithm for 3 minutes.
TSP4.cpp: The graph is read in as a natural order solution. The algorithm starts at the first city in the list and looks a certain distance ahead. Based on the number of cities it can see ahead in the list, it picks the closest city, swaps it to be the next city in the list and then moves to it. The algorithm travels the path a predetermined number of times trying to optimize the sub paths.
TSP5.cpp: A return to a greedy style approach where the index with the maximum distance from city 0 is selected as the "furthest" city. This city was placed at half the lists' size away from index 0. The greedy algorithm is then applied from each city as a starting point to build a solution from the 2 greedy sub paths.
TSP6.cpp: The "best" algorithm was found to be TSP2.cpp in that it provided the best route. The idea to maximize computational time was borrowed from TSP3.cpp, as well as some of the randomness. The idea is to try to run the greedy algorithm on every city if the graph is small enough, but once its large enough it tries to run the greedy algorithm on as many randomly selected starting points as possible within the hard coded time limit (3 minutes in this case). Starting points can only be tried once in a given run so small enough graphs are guaranteed to try each starting city once, and large graphs will not waste computational time on repeating starting points.

We ended up selecting TSP6.cpp because it consistently provided the best results, while maximizing computational time on each problem while not repeating calculations unneccessarily. The results weren't good enough to win the class competition, but prior to result verification by the Professor/TA's we were placed 11 out of 41 sets of results. We were allowed to research and implement any methods we wanted (as long as sources were properly cited), but I took the opportunity as challenge to myself to see what I could come up with and am happy with the results. If I was to do anything differently, I would likely implement some form of 2OPT in addition to the greedy algorithm to try to better my results.
